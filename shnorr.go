package shnorr

import (
	"github.com/dedis/crypto/abstract"
	"github.com/dedis/crypto/ed25519"
	"github.com/dedis/crypto/random"
)

//Signature Shnorr-signature where the notation (e,s) is taken from https://en.wikipedia.org/wiki/Schnorr_signature
type Signature struct {
	e abstract.Scalar
	s abstract.Scalar
}

var suite = ed25519.NewAES128SHA256Ed25519(true)

//NewSignature creates a new Signature given the message msg and the private key privkey
func NewSignature(msg []byte, privKey abstract.Scalar) Signature {
	sig := &Signature{}
	hashFunc := suite.Hash()
	k := suite.Scalar().Pick(random.Stream)
	//compute r = g^k
	r := suite.Point().Mul(nil, k)
	// compute e = H(msg || r)
	b, _ := r.MarshalBinary()
	hashFunc.Write(msg)
	e := hashFunc.Sum(b)
	eScalar := suite.Scalar().SetBytes(e)
	// s = k - x*e
	s := suite.Scalar().Sub(k, suite.Scalar().Mul(privKey, eScalar))
	sig.e = eScalar
	sig.s = s
	return *sig
}

func (signature *Signature) verify(msg []byte, publicKey abstract.Point) bool {
	hashFunc := suite.Hash()
	// compute r_v = g^s * publicKey^e
	gs := suite.Point().Mul(nil, signature.s)
	ye := suite.Point().Mul(publicKey, signature.e)
	rv := suite.Point().Add(gs, ye)
	// compute e_v = H(msg || r_v)
	hashFunc.Write(msg)
	rvBytes, _ := rv.MarshalBinary()
	ev := hashFunc.Sum(rvBytes)
	// transform ev into a Scalar
	evScalar := suite.Scalar().SetBytes(ev)
	return evScalar.Equal(signature.e)

}

// MarshalBinary encodes the receiver into a binary form and returns the result.
func (signature *Signature) MarshalBinary() (data []byte, err error) {
	b1, err1 := signature.e.MarshalBinary()
	b2, err2 := signature.s.MarshalBinary()
	if err1 != nil {
		err = err1
	}
	if err2 != nil {
		err = err2
	}
	data = append(b1, b2...)
	return
}

//UnmarshalBinary must be able to decode the form generated by MarshalBinary. UnmarshalBinary must copy the data if it wishes to retain the data after returning.
func (signature *Signature) UnmarshalBinary(b []byte) error {
	b1 := b[:32]
	b2 := b[32:]
	e := suite.Scalar()

	err1 := e.UnmarshalBinary(b1)
	if err1 != nil {
		return err1
	}
	s := suite.Scalar()
	err2 := s.UnmarshalBinary(b2)
	if err2 != nil {
		return err2
	}
	signature.e = e
	signature.s = s
	return nil
}
